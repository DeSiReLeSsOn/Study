"""Часто бывает полезно представление класса в виде строки. В Питоне существует несколько методов,
которые вы можете определить для настройки поведения встроенных функций при представлении вашего класса.
__str__(self)
Определяет поведение функции str(), вызванной для экземпляра вашего класса.
 
__repr__(self)
Определяет поведение функции repr(), вызыванной для экземпляра вашего класса. Главное отличие от str() в целевой аудитории.
repr() больше предназначен для машинно-ориентированного вывода (более того, это часто должен быть валидный код на Питоне),
а str() предназначен для чтения людьми.
 
__unicode__(self)
Определяет поведение функции unicode(), вызыванной для экземпляра вашего класса. unicode() похож на str(), но возвращает строку в юникоде.
Будте осторожны: если клиент вызывает str() на экземпляре вашего класса, а вы определили только __unicode__(), то это не будет работать.
Постарайтесь всегда определять __str__() для случая, когда кто-то не имеет такой роскоши как юникод.
 
__format__(self, formatstr)
Определяет поведение, когда экземпляр вашего класса используется в форматировании строк нового стиля.
Например, "Hello, {0:abc}!".format(a) приведёт к вызову a.__format__("abc").
Это может быть полезно для определения ваших собственных числовых или строковых типов,
которым вы можете захотеть предоставить какие-нибудь специальные опции форматирования.
 
__hash__(self)
Определяет поведение функции hash(), вызыванной для экземпляра вашего класса.
Метод должен возвращать целочисленное значение, которое будет использоваться для быстрого сравнения ключей в словарях.
Заметьте, что в таком случае обычно нужно определять и __eq__ тоже. Руководствуйтесь следующим правилом: a == b подразумевает hash(a) == hash(b).
 
__nonzero__(self)
Определяет поведение функции bool(), вызванной для экземпляра вашего класса. Должна вернуть True или False, в зависимости от того,
когда вы считаете экземпляр соответствующим True или False.
 
__dir__(self)
Определяет поведение функции dir(), вызванной на экземпляре вашего класса.
Этот метод должен возвращать пользователю список атрибутов.
Обычно, определение __dir__ не требуется, но может быть жизненно важно для интерактивного использования вашего класса,
если вы переопределили __getattr__ или __getattribute__ (с которыми вы встретитесь в следующей части), или каким-либо другим образом динамически создаёте атрибуты.
 
__sizeof__(self)
Определяет поведение функции sys.getsizeof(), вызыванной на экземпляре вашего класса. Метод должен вернуть размер вашего объекта в байтах.
Он главным образом полезен для классов, определённых в расширениях на C, но всё-равно полезно о нём знать."""



"""Контроль доступа к атрибутам:
__getattr__(self, name)
Вы можете определить поведение для случая, когда пользователь пытается обратиться к атрибуту, который не существует (совсем или пока ещё).
Это может быть полезным для перехвата и перенаправления частых опечаток, предупреждения об использовании устаревших атрибутов (вы можете всё-равно вычислить и вернуть этот атрибут, если хотите),
или хитро возвращать AttributeError, когда это вам нужно.
Правда, этот метод вызывается только когда пытаются получить доступ к несуществующему атрибуту, поэтому это не очень хорошее решение для инкапсуляции.
 
__setattr__(self, name, value)
В отличии от __getattr__, __setattr__ решение для инкапсуляции. Этот метод позволяет вам определить поведение для присвоения значения атрибуту, независимо от того существует атрибут или нет.
То есть, вы можете определить любые правила для любых изменений значения атрибутов. Впрочем, вы должны быть осторожны с тем, как использовать __setattr__, смотрите пример нехорошего случая в конце этого списка.
 
__delattr__
Это то же, что и __setattr__, но для удаления атрибутов, вместо установки значений. Здесь требуются те же меры предосторожности,
что и в __setattr__ чтобы избежать бесконечной рекурсии (вызов del self.name в определении __delattr__ вызовет бесконечную рекурсию).
 
__getattribute__(self, name)
__getattribute__ выглядит к месту среди своих коллег __setattr__ и __delattr__, но я бы не рекомендовал вам его использовать.
__getattribute__ может использоваться только с классами нового типа (в новых версиях Питона все классы нового типа,
а в старых версиях вы можете получить такой класс унаследовавшись от object). Этот метод позволяет вам определить поведение для каждого случая доступа к атрибутам (а не только к несуществующим, как __getattr__(self, name)).
Он страдает от таких же проблем с бесконечной рекурсией, как и его коллеги (на этот раз вы можете вызывать __getattribute__ у базового класса, чтобы их предотвратить).
Он, так же, главным образом устраняет необходимость в __getattr__, который в случае реализации __getattribute__ может быть вызван только явным образом или в случае генерации исключения AttributeError.
Вы конечно можете использовать этот метод (в конце концов, это ваш выбор), но я бы не рекомендовал, потому что случаев, когда он действительно полезен очень мало
(намного реже нужно переопределять поведение при получении, а не при установке значения) и реализовать его без возможных ошибок очень сложно."""


def __setattr__(self, name, value):
    self.name = value
    # это рекурсия, так как всякий раз, когда любому атрибуту присваивается значение,
    # вызывается  __setattr__().
    # тоесть, на самом деле это равнозначно self.__setattr__('name', value). 
    # Так как метод вызывает сам себя, рекурсия продолжится бесконечно, пока всё не упадёт

def __setattr__(self, name, value):
    self.__dict__[name] = value # присваивание в словарь переменных класса
    # дальше определение произвольного поведения 


class AccessCounter(object):
    '''Класс, содержащий атрибут value и реализующий счётчик доступа к нему.
    Счётчик увеличивается каждый раз, когда меняется value.'''

    def __init__(self, val):
        super(AccessCounter, self).__setattr__('counter', 0)
        super(AccessCounter, self).__setattr__('value', val)

    def __setattr__(self, name, value):
        if name == 'value':
            super(AccessCounter, self).__setattr__('counter', self.counter + 1)
        # Не будем делать здесь никаких условий.
        # Если вы хотите предотвратить изменение других атрибутов,
        # выбросьте исключение AttributeError(name)
        super(AccessCounter, self).__setattr__(name, value)

    def __delattr__(self, name):
        if name == 'value':
            super(AccessCounter, self).__setattr__('counter', self.counter + 1)
        super(AccessCounter, self).__delattr__(name)