"""__new__(cls, [...)
Это первый метод, который будет вызван при инициализации объекта. Он принимает в качестве параметров класс и потом любые другие аргументы,
которые будут переданы в __init__. __new__ используется весьма редко, но иногда бывает полезен, 
в частности, когда класс наследуется от неизменяемого (immutable) типа, такого как кортеж (tuple) или строка. 

 
__init__(self, [...)
Инициализатор класса. Ему передаётся всё, с чем был вызван первоначальный конструктор 
(так, например, если мы вызываем x = SomeClass(10, 'foo'), __init__ получит 10 и 'foo' в качестве аргументов.
 __init__ почти повсеместно используется при определении классов.
 
__del__(self)
Если __new__ и __init__ образуют конструктор объекта, __del__ это его деструктор. 
Он не определяет поведение для выражения del x (поэтому этот код не эквивалентен x.__del__()).
 Скорее, он определяет поведение объекта в то время, когда объект попадает в сборщик мусора. 
Это может быть довольно удобно для объектов, которые могут требовать дополнительных чисток во время удаления, таких как сокеты или файловыве объекты.
Однако, нужно быть осторожным, так как нет гарантии, что __del__ будет вызван, если объект продолжает жить, когда интерпретатор завершает работу.
Поэтому __del__ не может служить заменой для хороших программистских практик (всегда завершать соединение, если закончил с ним работать и тому подобное).
Фактически, из-за отсутствия гарантии вызова, __del__ не должен использоваться почти никогда; используйте его с осторожностью!"""


from os.path import join

class FileObject:
    '''Обёртка для файлового объекта, чтобы быть уверенным в том, что файл будет закрыт при удалении.'''

    def __init__(self, filepath='~', filename='sample.txt'):
        # открыть файл filename в filepath в режиме чтения и записи
        self.file = open(join(filepath, filename), 'r+')

    def __del__(self):
        self.file.close()
        del self.file 


"""Операторы сравнения:
__cmp__(self, other)
Самый базовый из методов сравнения. Он, в действительности, определяет поведение для всех операторов сравнения (>, ==, !=, итд.),
но не всегда так, как вам это нужно (например, если эквивалентность двух экземпляров определяется по одному критерию, а то что один больше другого по какому-нибудь другому).
__cmp__ должен вернуть отрицательное число, если self < other, ноль, если self == other, и положительное число в случае self > other. 
Но, обычно, лучше определить каждое сравнение, которое вам нужно, чем определять их всех в __cmp__. 
Но __cmp__ может быть хорошим способом избежать повторений и увеличить ясность, когда все необходимые сравнения оперерируют одним критерием.
 
__eq__(self, other)
Определяет поведение оператора равенства, ==.
 
__ne__(self, other)
Определяет поведение оператора неравенства, !=.
 
__lt__(self, other)
Определяет поведение оператора меньше, <.
 
__gt__(self, other)
Определяет поведение оператора больше, >.
 
__le__(self, other)
Определяет поведение оператора меньше или равно, <=.
 
__ge__(self, other)
Определяет поведение оператора больше или равно, >=.""" 

class Word(str):
    '''Класс для слов, определяющий сравнение по длине слов.'''

    def __new__(cls, word):
        # Мы должны использовать __new__, так как тип str неизменяемый
        # и мы должны инициализировать его раньше (при создании)
        if ' ' in word:
            print("Value contains spaces. Truncating to first space.")
            word = word[:word.index(' ')] # Теперь Word это все символы до первого пробела
        return str.__new__(cls, word)

    def __gt__(self, other):
        return len(self) > len(other)
    def __lt__(self, other):
        return len(self) < len(other)
    def __ge__(self, other):
        return len(self) >= len(other)
    def __le__(self, other):
        return len(self) <= len(other)


"""Унарные операторы и функции:
__pos__(self)
Определяет поведение для унарного плюса (+some_object)
 
__neg__(self)
Определяет поведение для отрицания(-some_object)
 
__abs__(self)
Определяет поведение для встроенной функции abs().
 
__invert__(self)
Определяет поведение для инвертирования оператором ~.
 
__round__(self, n)
Определяет поведение для встроенной функции round(). n это число знаков после запятой, до которого округлить.
 
__floor__(self)
Определяет поведение для math.floor(), то есть, округления до ближайшего меньшего целого.
 
__ceil__(self)
Определяет поведение для math.ceil(), то есть, округления до ближайшего большего целого.
 
__trunc__(self)
Определяет поведение для math.trunc(), то есть, обрезания до целого.""" 


"""Обычные арифметические операторы:
__add__(self, other)
Сложение.
 
__sub__(self, other)
Вычитание.
 
__mul__(self, other)
Умножение.
 
__floordiv__(self, other)
Целочисленное деление, оператор //.
 
__div__(self, other)
Деление, оператор /.
 
__truediv__(self, other)
Правильное деление. Заметьте, что это работает только когда используется from __future__ import division.
 
__mod__(self, other)
Остаток от деления, оператор %.
 
__divmod__(self, other)
Определяет поведение для встроенной функции divmod().
 
__pow__
Возведение в степень, оператор **.
 
__lshift__(self, other)
Двоичный сдвиг влево, оператор <<.
 
__rshift__(self, other)
Двоичный сдвиг вправо, оператор >>.
 
__and__(self, other)
Двоичное И, оператор &.
 
__or__(self, other)
Двоичное ИЛИ, оператор |.
 
__xor__(self, other)
Двоичный xor, оператор ^.""" 


"""Магические методы преобразования типов:
__int__(self)
Преобразование типа в int.
 
__long__(self)
Преобразование типа в long.
 
__float__(self)
Преобразование типа в float.
 
__complex__(self)
Преобразование типа в комплексное число.
 
__oct__(self)
Преобразование типа в восьмеричное число.
 
__hex__(self)
Преобразование типа в шестнадцатиричное число.
 
__index__(self)
Преобразование типа к int, когда объект используется в срезах (выражения вида [start:stop:step]).
Если вы определяете свой числовый тип, который может использоваться как индекс списка, вы должны определить __index__.
 
__trunc__(self)
Вызывается при math.trunc(self). Должен вернуть своё значение, обрезанное до целочисленного типа (обычно long).
 
__coerce__(self, other)
Метод для реализации арифметики с операндами разных типов. __coerce__ должен вернуть None если преобразование типов невозможно.
Если преобразование возможно, он должен вернуть пару (кортеж из 2-х элементов) из self и other, преобразованные к одному типу."""

